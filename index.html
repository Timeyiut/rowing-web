<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Rowing Trajectory Analysis v8.0</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <style>
        :root { --bg: #121212; --panel: rgba(30, 30, 30, 0.9); --accent: #00E5FF; }
        body { margin: 0; background: var(--bg); color: #fff; font-family: monospace; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }

        /* ä¸»èˆå° */
        #stage { flex: 1; position: relative; background: #000; display: flex; justify-content: center; align-items: center; }
        video { position: absolute; width: 100%; height: 100%; object-fit: contain; opacity: 0; pointer-events: none; }
        canvas { position: absolute; width: 100%; height: 100%; object-fit: contain; }
        .mirrored { transform: scaleX(-1); }

        /* æ•¸æ“šå„€è¡¨æ¿ */
        #hud {
            position: absolute; top: 10px; left: 10px; padding: 10px;
            background: var(--panel); border-radius: 8px; border-left: 4px solid var(--accent);
            pointer-events: none; z-index: 10;
        }
        .row { display: flex; gap: 15px; margin-bottom: 5px; font-size: 14px; }
        .label { color: #aaa; }
        .val { font-weight: bold; font-size: 16px; }
        
        /* ç‹€æ…‹æŒ‡ç¤ºç‡ˆ */
        #status-pill {
            display: inline-block; padding: 4px 8px; border-radius: 4px; 
            font-weight: bold; font-size: 12px; margin-top: 5px;
            background: #333; color: #fff; width: 100%; text-align: center;
        }

        /* åº•éƒ¨æ§åˆ¶ */
        #controls {
            height: 70px; background: #1e1e1e; border-top: 1px solid #333;
            display: flex; gap: 10px; padding: 10px; align-items: center; justify-content: center; z-index: 20;
        }
        button, label {
            flex: 1; height: 100%; border: none; border-radius: 6px;
            background: #333; color: #ccc; font-weight: bold; font-size: 12px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer;
        }
        .active { background: var(--accent); color: #000; }
        .btn-icon { font-size: 18px; margin-bottom: 2px; }

        /* å•Ÿå‹•é®ç½© */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #start-btn { flex: 0; height: 50px; width: 200px; font-size: 18px; background: var(--accent); color: #000; border-radius: 25px; }
        
        #file-input { display: none; }
    </style>
</head>
<body>

    <div id="overlay">
        <button id="start-btn" onclick="initSystem()">ğŸš€ å•Ÿå‹•è»Œè·¡åˆ†æ</button>
    </div>

    <div id="stage">
        <video id="video" playsinline muted webkit-playsinline loop crossorigin="anonymous"></video>
        <canvas id="canvas"></canvas>

        <div id="hud">
            <div class="row"><span class="label">Phase:</span> <span id="val-phase" class="val">--</span></div>
            <div class="row"><span class="label">Knee:</span> <span id="val-knee" class="val">0Â°</span></div>
            <div class="row"><span class="label">Elbow:</span> <span id="val-elbow" class="val">0Â°</span></div>
            <div id="status-pill">SYSTEM READY</div>
            <div style="margin-top:5px; font-size:10px; color:#666;">
                <span style="color:#FF3D00">â—</span> Pull (Drive) 
                <span style="color:#00E676; margin-left:5px;">â—</span> Return (Recovery)
            </div>
        </div>
    </div>

    <div id="controls">
        <button class="btn-force" onclick="forceRender()">
            <div class="btn-icon">âš¡</div>å¼·åˆ¶åŸ·è¡Œ
        </button>
        <label for="file-input" class="active">
            <div class="btn-icon">ğŸ“‚</div>åŒ¯å…¥å½±ç‰‡
        </label>
        <button onclick="startCamera()">
            <div class="btn-icon">ğŸ“·</div>ç›¸æ©Ÿ
        </button>
        <button onclick="clearTrails()">
            <div class="btn-icon">ğŸ—‘ï¸</div>æ¸…é™¤è»Œè·¡
        </button>
    </div>

    <input type="file" id="file-input" accept="video/*">

<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let pose = null;
    let isProcessing = false;
    let isVideoMode = false;
    let facingMode = 'user';
    let animationId;

    // --- åˆ’èˆ¹åˆ†æè®Šæ•¸ ---
    let prevKneeAngle = 0;
    let currentPhase = "IDLE"; // 'DRIVE' or 'RECOVERY'
    
    // è»Œè·¡ç·©è¡å€ (åªå­˜æœ€è¿‘ 100 é»)
    const TRAIL_LENGTH = 120;
    let trails = {
        knee: [],
        elbow: [],
        ankle: [],
        wrist: [] // æ‰‹æŠŠä½ç½®
    };

    // --- 1. åˆå§‹åŒ– ---
    async function initSystem() {
        document.getElementById('overlay').style.display = 'none';
        try {
            pose = new Pose({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}` });
            pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            pose.onResults(onResults);
            await pose.initialize();
            document.getElementById('status-pill').innerText = "WAITING FOR VIDEO";
        } catch (e) { alert("åˆå§‹åŒ–å¤±æ•—"); }
    }

    // --- 2. æ ¸å¿ƒåˆ†æèˆ‡ç¹ªåœ– (OpenCV Style) ---
    function onResults(results) {
        // 1. æº–å‚™ç•«å¸ƒ
        if (canvas.width !== video.videoWidth) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        }
        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // ç¹ªè£½åŠé€æ˜é»‘åº•ï¼Œè®“è»Œè·¡æ›´æ˜é¡¯
        // ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        // ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // ç¹ªè£½å½±ç‰‡åº•åœ–
        ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

        if (results.poseLandmarks) {
            const lm = results.poseLandmarks;
            const w = canvas.width;
            const h = canvas.height;

            // 2. é—œéµç¯€é»åº§æ¨™æå– (OpenCV Style: 25, 27, 13, 15)
            // ä½¿ç”¨å·¦å´æˆ–å³å´ (æ ¹æ“šå¯è¦‹åº¦ç°¡å–®åˆ¤æ–·ï¼Œé€™è£¡é è¨­å–å³å´ å¶æ•¸ç‚ºå³, å¥‡æ•¸ç‚ºå·¦ã€‚MediaPipe: 11å·¦è‚©, 12å³è‚©...)
            // ç‚ºäº†ç°¡åŒ–ï¼Œæˆ‘å€‘å–å¯è¦‹åº¦è¼ƒé«˜çš„ä¸€å´ï¼Œæˆ–è€…é è¨­å·¦å´(å´é¢éŒ„å½±å¸¸ç”¨)
            // 23:å·¦é«–, 25:å·¦è†, 27:å·¦è¸ | 11:å·¦è‚©, 13:å·¦è‚˜, 15:å·¦è…•
            
            // ç°¡å–®çš„å´é‚Šè‡ªå‹•åµæ¸¬ï¼šæ¯”è¼ƒå·¦è‚©å’Œå³è‚©çš„ visibility
            const isLeft = lm[11].visibility > lm[12].visibility;
            const offset = isLeft ? 0 : 1; 

            const ankle = { x: lm[27+offset].x * w, y: lm[27+offset].y * h };
            const knee  = { x: lm[25+offset].x * w, y: lm[25+offset].y * h };
            const hip   = { x: lm[23+offset].x * w, y: lm[23+offset].y * h };
            const elbow = { x: lm[13+offset].x * w, y: lm[13+offset].y * h };
            const wrist = { x: lm[15+offset].x * w, y: lm[15+offset].y * h }; // æ‰‹æŠŠ
            const shoulder = { x: lm[11+offset].x * w, y: lm[11+offset].y * h };

            // 3. è¨ˆç®—è§’åº¦èˆ‡ç›¸ä½åˆ¤æ–·
            const kneeAngle = getAngle(hip, knee, ankle);
            const elbowAngle = getAngle(shoulder, elbow, wrist);
            
            // ç›¸ä½é‚è¼¯ï¼šè†è“‹è§’åº¦è®Šå¤§ = Drive(æ¨è…¿)ï¼Œè®Šå° = Recovery(æ”¶è…¿)
            // åŠ å…¥é–¾å€¼é¿å…æŠ–å‹•
            if (kneeAngle > prevKneeAngle + 0.5) {
                currentPhase = "DRIVE";
            } else if (kneeAngle < prevKneeAngle - 0.5) {
                currentPhase = "RECOVERY";
            }
            prevKneeAngle = kneeAngle;

            // 4. æ›´æ–°è»Œè·¡ Buffer
            const pointData = { phase: currentPhase, ...knee }; // å­˜è†è“‹
            updateTrail(trails.knee, knee, currentPhase);
            updateTrail(trails.elbow, elbow, currentPhase);
            updateTrail(trails.ankle, ankle, currentPhase); // è¸é—œç¯€é€šå¸¸ä¸å‹•ï¼Œä½†ä¹Ÿç•«å‡ºä¾†ç¢ºèª
            updateTrail(trails.wrist, wrist, currentPhase); // æ‰‹æŠŠè»Œè·¡

            // 5. ç¹ªè£½è»Œè·¡ (OpenCV Style)
            drawTrail(trails.knee);
            drawTrail(trails.elbow);
            drawTrail(trails.wrist); // æ‰‹æŠŠå¾ˆé‡è¦
            
            // 6. ç¹ªè£½ç•¶å‰éª¨æ¶ (ç°¡åŒ–ç‰ˆï¼šåªç•«ç·šèˆ‡é»)
            drawSkeleton(ctx, [shoulder, elbow, wrist], "#FFF", 4); // æ‰‹è‡‚
            drawSkeleton(ctx, [shoulder, hip, knee, ankle], "#FFF", 4); // èº«é«”èˆ‡è…¿
            
            // ç¹ªè£½é—œéµé» (Joints)
            drawKeypoint(ctx, knee, "#FFD700"); // é‡‘è‰²è†è“‹
            drawKeypoint(ctx, elbow, "#FFD700");
            drawKeypoint(ctx, ankle, "#888");   // ç°è‰²è…³è¸
            drawKeypoint(ctx, wrist, "#00E5FF"); // è—è‰²æ‰‹æŠŠ

            // 7. æ›´æ–° UI
            updateHUD(currentPhase, kneeAngle, elbowAngle);
        }
        ctx.restore();
    }

    // --- 3. è»Œè·¡ç®¡ç†ç³»çµ± ---
    function updateTrail(trailArray, point, phase) {
        trailArray.push({ x: point.x, y: point.y, phase: phase });
        if (trailArray.length > TRAIL_LENGTH) {
            trailArray.shift(); // ç§»é™¤æœ€èˆŠçš„é»
        }
    }

    function drawTrail(trailArray) {
        if (trailArray.length < 2) return;
        
        // ç•«ç·š
        for (let i = 1; i < trailArray.length; i++) {
            const p1 = trailArray[i-1];
            const p2 = trailArray[i];
            
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            
            // é¡è‰²é‚è¼¯ï¼šDRIVE = ç´…, RECOVERY = ç¶ 
            if (p2.phase === "DRIVE") {
                ctx.strokeStyle = "rgba(255, 61, 0, 0.8)"; // Red Orange
                ctx.lineWidth = 4;
            } else {
                ctx.strokeStyle = "rgba(0, 230, 118, 0.6)"; // Green
                ctx.lineWidth = 2; // å›æ§³ç·šæ¢ç´°ä¸€é»
            }
            ctx.stroke();
        }
    }

    // --- 4. ç¹ªåœ–è¼”åŠ©å‡½å¼ ---
    function drawKeypoint(ctx, p, color) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    function drawSkeleton(ctx, points, color, width) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
        }
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.lineCap = "round";
        ctx.stroke();
    }

    function getAngle(p1, p2, p3) { // p2 æ˜¯ä¸­é–“é»
        // ä½¿ç”¨ç°¡å–®çš„å‘é‡è§’åº¦è¨ˆç®—
        // atan2 å›å‚³ -PI åˆ° PI
        const a1 = Math.atan2(p1.y - p2.y, p1.x - p2.x);
        const a2 = Math.atan2(p3.y - p2.y, p3.x - p2.x);
        let ang = Math.abs((a2 - a1) * 180 / Math.PI);
        if (ang > 180) ang = 360 - ang;
        return Math.round(ang);
    }

    function updateHUD(phase, knee, elbow) {
        document.getElementById('val-phase').innerText = phase;
        document.getElementById('val-knee').innerText = knee + "Â°";
        document.getElementById('val-elbow').innerText = elbow + "Â°";
        
        const pill = document.getElementById('status-pill');
        if (phase === "DRIVE") {
            pill.style.background = "#FF3D00";
            pill.innerText = "POWER PHASE (DRIVE)";
        } else if (phase === "RECOVERY") {
            pill.style.background = "#00E676";
            pill.style.color = "#000";
            pill.innerText = "RECOVERY PHASE";
        }
    }

    function clearTrails() {
        trails.knee = [];
        trails.elbow = [];
        trails.ankle = [];
        trails.wrist = [];
    }

    // --- 5. ç³»çµ±æ§åˆ¶ (iOS ç©©å®šç‰ˆé‚è¼¯) ---
    document.getElementById('file-input').onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        stopAll();
        isVideoMode = true;
        canvas.classList.remove('mirrored');
        
        const url = URL.createObjectURL(file);
        video.src = url;
        video.onloadeddata = () => {
            const p = video.play();
            if (p) p.then(() => { isProcessing = true; processLoop(); })
                   .catch(() => alert("è«‹é»æ“Šå¼·åˆ¶åŸ·è¡Œ"));
        };
    };

    function startCamera() {
        stopAll();
        isVideoMode = false;
        canvas.classList.add('mirrored');
        navigator.mediaDevices.getUserMedia({video: {facingMode: 'user', width: 1280, height: 720}})
            .then(s => {
                video.srcObject = s;
                video.onloadedmetadata = () => { video.play(); isProcessing = true; processLoop(); };
            }).catch(e => alert("ç›¸æ©Ÿæ¬Šé™å¤±æ•—"));
    }

    function forceRender() {
        if (video.src || video.srcObject) {
            video.play();
            isProcessing = true;
            processLoop();
        }
    }

    function processLoop() {
        if (!isProcessing) return;
        if (!video.paused && !video.ended) pose.send({image: video});
        animationId = requestAnimationFrame(processLoop);
    }

    function stopAll() {
        isProcessing = false;
        clearTrails();
        if (animationId) cancelAnimationFrame(animationId);
        video.pause();
        if (video.srcObject) { video.srcObject.getTracks().forEach(t=>t.stop()); video.srcObject=null;}
        video.src="";
    }
</script>
</body>
</html>