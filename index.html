<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rowing Tech Analysis - Engineering Edition</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <style>
        :root { --main-bg: #0a0a0a; --panel-bg: rgba(30, 30, 30, 0.85); --accent: #00e5ff; }
        body { margin: 0; background: var(--main-bg); color: #fff; font-family: 'JetBrains Mono', monospace; overflow: hidden; }
        #app { display: flex; flex-direction: column; width: 100vw; height: 100vh; position: relative; }
        
        /* æ ¸å¿ƒç•«å¸ƒï¼šç¢ºä¿å¯¬é«˜ç”±å½±ç‰‡æ¯”ä¾‹æ±ºå®š */
        canvas { width: 100%; height: auto; max-height: 80vh; object-fit: contain; background: #000; }
        .mirrored { transform: scaleX(-1); }
        video { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; }

        /* å·¥ç¨‹å¸«é¢¨æ ¼å„€è¡¨æ¿ */
        #dashboard {
            position: absolute; top: 10px; left: 10px; right: 10px;
            padding: 12px; background: var(--panel-bg); 
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
            border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); z-index: 100;
        }
        .stat { font-size: 13px; line-height: 1.5; color: #ccc; }
        .stat b { color: var(--accent); }
        #hr-val { color: #ff3d00; font-size: 18px; font-weight: bold; }

        /* å½±ç‰‡é€²åº¦æ§åˆ¶ */
        #vid-seeker {
            position: absolute; bottom: 85px; left: 20px; right: 20px;
            height: 6px; background: #333; border-radius: 3px; display: none; cursor: pointer;
        }
        #vid-progress { width: 0%; height: 100%; background: var(--accent); border-radius: 3px; }

        /* åº•éƒ¨æ§åˆ¶æ¬„ */
        #controls {
            position: absolute; bottom: 15px; width: 100%;
            display: flex; justify-content: center; flex-wrap: wrap; gap: 8px; z-index: 100;
        }
        button, label {
            padding: 8px 16px; border-radius: 4px; border: 1px solid var(--accent);
            background: transparent; color: var(--accent); font-weight: bold; cursor: pointer;
            transition: 0.2s; font-size: 12px;
        }
        button:active, label:active { background: var(--accent); color: #000; }
        #file-input { display: none; }
    </style>
</head>
<body>

<div id="app">
    <video id="source_video" playsinline muted webkit-playsinline></video>
    <canvas id="main_canvas"></canvas>

    <div id="vid-seeker"><div id="vid-progress"></div></div>

    <div id="dashboard">
        <div class="stat">CLOCK: <span id="ts">--:--:--.---</span></div>
        <div class="stat">HEART: <span id="hr-val">-- bpm</span></div>
        <div class="stat">STATE: <b id="ph-val">IDLE</b></div>
        <div class="stat">KNEE/HIP: <b id="k-val">0</b>Â° / <b id="h-val">0</b>Â°</div>
    </div>

    <div id="controls">
        <button onclick="startLive()">ğŸ“¸ LIVEç›¸æ©Ÿ</button>
        <button onclick="toggleFacing()">ğŸ”„ é¡é ­åˆ‡æ›</button>
        <label for="file-input">ğŸ¬ åŒ¯å…¥å½±ç‰‡</label>
        <input type="file" id="file-input" accept="video/*">
        <button onclick="connectHR()">ğŸ”— è—ç‰™é€£ç·š</button>
        <button style="border-color:#4caf50; color:#4caf50;" onclick="downloadData()">ğŸ’¾ æ•¸æ“šå°å‡º</button>
    </div>
</div>

<script>
    const video = document.getElementById('source_video');
    const canvas = document.getElementById('main_canvas');
    const ctx = canvas.getContext('2d');
    const seeker = document.getElementById('vid-seeker');
    const progressBar = document.getElementById('vid-progress');

    let camera = null;
    let isStreamActive = false;
    let facingMode = 'user';
    let bleHR = 0;
    let dataset = [["Time", "HR", "Knee", "Hip", "Phase"]];

    // --- 1. åˆå§‹åŒ– Pose Engine ---
    const pose = new Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
    });
    
    // modelComplexity 0 = æ•ˆèƒ½å„ªå…ˆ, 1 = æº–ç¢ºåº¦å¹³è¡¡
    pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

    pose.onResults((res) => {
        if (!res.poseLandmarks) return;

        // å‹•æ…‹èª¿æ•´ Canvas å°ºå¯¸ä»¥åŒ¹é…ä¾†æº
        if (canvas.width !== video.videoWidth) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
        }

        ctx.save();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(res.image, 0, 0, canvas.width, canvas.height);
        
        // ç¹ªè£½éª¨æ¶
        drawConnectors(ctx, res.poseLandmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
        drawLandmarks(ctx, res.poseLandmarks, {color: '#FF0000', lineWidth: 1});

        // è§’åº¦èˆ‡æ•¸æ“šè¨ˆç®—
        const lm = res.poseLandmarks;
        const knee = calcAngle(lm[23], lm[25], lm[27]);
        const hip = calcAngle(lm[11], lm[23], lm[25]);
        
        // æ›´æ–° UI (æ™‚é–“æˆ³è¨˜åœ¨åˆ†ææˆåŠŸæ™‚æ‰æ›´æ–°)
        const now = new Date();
        const ts = now.toISOString().split('T')[1].replace('Z', '');
        document.getElementById('ts').innerText = ts;
        document.getElementById('k-val').innerText = knee;
        document.getElementById('h-val').innerText = hip;
        
        let phase = (knee < 90) ? "CATCH" : (knee > 160) ? "FINISH" : "DRIVE";
        document.getElementById('ph-val').innerText = phase;

        dataset.push([ts, bleHR, knee, hip, phase]);
        ctx.restore();
    });

    function calcAngle(p1, p2, p3) {
        const rad = Math.atan2(p3.y - p2.y, p3.x - p2.x) - Math.atan2(p1.y - p2.y, p1.x - p2.x);
        let ang = Math.abs(rad * 180.0 / Math.PI);
        return Math.round(ang > 180 ? 360 - ang : ang);
    }

    // --- 2. å½±åƒåˆ†æå¾ªç’° (é—œéµä¿®æ­£é») ---
    async function analysisLoop() {
        if (!isStreamActive || video.paused || video.ended) return;
        await pose.send({image: video});
        
        // å½±ç‰‡é€²åº¦æ¢æ›´æ–°
        if (video.duration) {
            progressBar.style.width = (video.currentTime / video.duration * 100) + '%';
        }
        requestAnimationFrame(analysisLoop);
    }

    // --- 3. å½±åƒæºæ§åˆ¶ ---
    async function startLive() {
        isStreamActive = false;
        seeker.style.display = 'none';
        canvas.classList.add('mirrored');
        if (camera) await camera.stop();
        
        camera = new Camera(video, {
            onFrame: async () => { await pose.send({image: video}); },
            width: 1280, height: 720, facingMode: facingMode
        });
        camera.start();
        isStreamActive = true;
    }

    function toggleFacing() {
        facingMode = (facingMode === 'user') ? 'environment' : 'user';
        startLive();
    }

    document.getElementById('file-input').onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        isStreamActive = true;
        seeker.style.display = 'block';
        canvas.classList.remove('mirrored');
        if (camera) camera.stop();

        const url = URL.createObjectURL(file);
        video.src = url;
        
        // é‡è¦ï¼šç¢ºä¿å½±ç‰‡è¼‰å…¥æ•¸æ“šå¾Œå†æ’­æ”¾
        video.onloadedmetadata = () => {
            video.play();
            analysisLoop(); // å•Ÿå‹•å½±ç‰‡åˆ†æå¾ªç’°
        };
    };

    // é€²åº¦æ¢é»æ“Šè·³è½‰
    seeker.onclick = (e) => {
        const rect = seeker.getBoundingClientRect();
        const pct = (e.clientX - rect.left) / rect.width;
        video.currentTime = pct * video.duration;
    };

    // --- 4. å¤–éƒ¨é€£ç·š ---
    async function connectHR() {
        try {
            const dev = await navigator.bluetooth.requestDevice({ filters: [{ services: ['heart_rate'] }] });
            const server = await dev.gatt.connect();
            const char = await (await server.getPrimaryService('heart_rate')).getCharacteristic('heart_rate_measurement');
            await char.startNotifications();
            char.addEventListener('characteristicvaluechanged', (ev) => {
                bleHR = ev.target.value.getUint8(1);
                document.getElementById('hr-val').innerText = `${bleHR} bpm`;
            });
            alert("è—ç‰™å¿ƒç‡å¸¶å·²æˆåŠŸé€£ç·š");
        } catch (err) { alert("é€£ç·šå¤±æ•—ï¼Œè«‹æª¢æŸ¥è—ç‰™æ¬Šé™æˆ–ä½¿ç”¨ Bluefy ç€è¦½å™¨"); }
    }

    function downloadData() {
        const csvContent = "data:text/csv;charset=utf-8," + dataset.map(e => e.join(",")).join("\n");
        const link = document.createElement("a");
        link.href = encodeURI(csvContent);
        link.download = `rowing_analysis_${Date.now()}.csv`;
        link.click();
    }
</script>
</body>
</html>